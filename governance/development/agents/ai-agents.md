---
title: "AI Agents Convention"
description: Standards for creating and managing AI agents in .claude/agents/ (primary) and .opencode/agent/ (secondary) directories
category: explanation
subcategory: development
tags:
  - ai-agents
  - conventions
  - claude-code
  - development
  - standards
created: 2025-11-23
updated: 2026-01-29
---

# AI Agents Convention

This document defines the standards for creating, structuring, and managing AI agents in the `.claude/agents/` directory (primary source of truth) and `.opencode/agent/` directory (auto-generated). **Edit `.claude/agents/` first, then sync to `.opencode/`.** All agents must follow these conventions to ensure consistency, maintainability, and proper integration with the project.

## Overview

### What are AI Agents?

AI agents in this project are specialized AI assistants defined in the `.claude/agents/` directory (source of truth), with auto-generated OpenCode configuration in `.opencode/agent/`. Each agent has:

- **Specific expertise** in a particular domain or task
- **Defined tool permissions** limiting what operations it can perform
- **Clear responsibilities** to avoid overlap with other agents
- **Integration with project conventions** through references to AGENTS.md and convention documents
- **Unlimited token budget** - Focus on execution quality, not token usage (reliable compaction mechanism handles context management)

### Why We Need Agent Conventions

Without standards, agents can become:

- **Inconsistent** in structure and quality
- **Overlapping** in responsibilities, causing confusion
- **Insecure** through tool permission creep
- **Unmaintainable** as the project grows

This convention ensures all agents are:

- PASS: Well-structured and documented
- PASS: Single-purpose and focused
- PASS: Secure through explicit tool permissions
- PASS: Consistent with project standards

### Scope

This convention applies to:

- All agent files in `.claude/agents/` (primary) and `.opencode/agent/` (secondary)
- References to agents in `AGENTS.md`
- Agent validation rules in `repo-governance-checker`

### Dual-Mode Operation (Claude Code + OpenCode)

This repository maintains **dual compatibility** with both Claude Code and OpenCode:

- **`.claude/agents/`** - PRIMARY (Source of Truth)
  - Edit agents here first
  - Uses Claude Code format: tool arrays `[Read, Write]`
  - Model selection: `sonnet`, `haiku`, `opus`, or omit (inherits)

- **`.opencode/agent/`** - SECONDARY (Auto-Generated)
  - Synced from `.claude/agents/` using `npm run sync:claude-to-opencode`
  - Uses OpenCode format: boolean flags `{ read: true, write: true }`
  - Model selection: `zai/glm-4.7`, `zai/glm-4.5-air`, or `inherit`

**Workflow**: Always edit `.claude/agents/` first, then run sync script to regenerate `.opencode/agent/`.

**See**: [CLAUDE.md](../../../CLAUDE.md) for Claude Code documentation, [AGENTS.md](../../../AGENTS.md) for OpenCode documentation.

## Principles Implemented/Respected

**REQUIRED SECTION**: All development practice documents MUST include this section to ensure traceability from practices back to foundational values.

This practice respects the following core principles:

- **[Deliberate Problem-Solving](../../principles/general/deliberate-problem-solving.md)**: Agents must verify assumptions using Read, Grep, and Glob tools before acting. When multiple valid approaches exist (e.g., different markdown formatting options), agents present options rather than choosing silently. Agents stop and ask questions when requirements are unclear, rather than guessing implementation details. Agents advocate for simpler solutions when appropriate (e.g., suggesting flat structure over nested hierarchy). All agents follow the "Information Accuracy and Verification" requirements: verify facts with tools, state confidence levels explicitly, ask when uncertain.

- **[Explicit Over Implicit](../../principles/software-engineering/explicit-over-implicit.md)**: Agent tool permissions are explicitly whitelisted in frontmatter (not implicitly granted). Each agent declares exactly which tools it can access. Agent responsibilities are explicitly documented, not inferred. Frontmatter fields (name, description, tools, model, color) make agent capabilities transparent and discoverable through simple grep operations.

- **[Simplicity Over Complexity](../../principles/general/simplicity-over-complexity.md)**: Agents follow single-responsibility principle - one clear, focused purpose per agent. Flat directory structure (no subdirectories). Simple naming convention (kebab-case). Standard document structure across all agents. Rather than creating "Swiss Army knife" agents with dozens of capabilities, we create focused agents that do one thing well. See the principle's "For AI Agents" section for implementation guidelines on avoiding over-engineering:
  - Only implement what was requested (no speculative features)
  - Avoid premature abstractions (inline first, extract when needed)
  - Trust type systems and frameworks (no defensive code for guaranteed scenarios)
  - Apply the senior engineer test (question complexity proactively)
  - Prefer boring solutions (battle-tested patterns over clever code)

- **[Automation Over Manual](../../principles/software-engineering/automation-over-manual.md)**: Agents transform manual processes into automated workflows. Instead of manually validating 200+ markdown files, `repo-governance-checker` automates validation. Agents transform manual processes into repeatable, consistent automated workflows.

## Token Budget Philosophy

**CRITICAL GUIDELINE**: When invoking agents (`.claude/agents/` or `.opencode/agent/`) and workflows (`governance/workflows/`), **do NOT think about token budget constraints**.

### Why Unlimited Budget Mindset

- **Reliable compaction mechanism**: Claude Code handles context management through proven compaction
- **Quality is king**: Execution thoroughness matters more than token efficiency
- **No artificial constraints**: Agents should complete their work properly, not cut corners to save tokens
- **Workflow orchestration**: Multi-step workflows naturally require more tokens - this is expected and acceptable

### What This Means in Practice

When working with agents:

- PASS: **Do**: Let agents complete comprehensive validations, generate detailed reports, iterate until quality gates pass
- PASS: **Do**: Use multi-step workflows (check-fix iterations) without worrying about token usage
- PASS: **Do**: Focus on correct, thorough execution
- FAIL: **Don't**: Skip steps to save tokens
- FAIL: **Don't**: Reduce validation scope due to token concerns
- FAIL: **Don't**: Avoid iteration loops because of token budget fears

### Compaction Handles Scale

- Large repository audits â†’ Compaction preserves key findings
- Multi-iteration workflows â†’ Compaction maintains essential state
- Comprehensive reports â†’ Written to files, conversation can be compacted
- Long validation runs â†’ Progressive writing ensures nothing is lost

**Bottom line**: Trust the compaction mechanism. Execute quality work. Token budget is effectively unlimited for agent and workflow operations.

## Conventions Implemented/Respected

**REQUIRED SECTION**: All development practice documents MUST include this section to ensure traceability from practices to documentation standards.

This practice implements/respects the following conventions:

- **[File Naming Convention](../../conventions/structure/file-naming.md)**: Agents follow kebab-case naming pattern (`agent-name.md`). Agent names must match frontmatter `name` field.

- **[Linking Convention](../../conventions/formatting/linking.md)**: All references to conventions and other documents use relative paths with `.md` extension. Ensures GitHub-compatible markdown across all agent files.

- **[Emoji Usage Convention](../../conventions/formatting/emoji.md)**: Agent prompt files CAN use emojis for enhanced scannability (allowed location per convention). Emojis are particularly useful for criticality level definitions (CRITICAL, HIGH, MEDIUM, LOW), section headers (Purpose, Key Concepts, Reference), and status indicators in examples (PASS: Correct, FAIL: Incorrect, Warning). `.claude/agents/README.md` (primary) and `.opencode/agent/README.md` (secondary) use colored square emojis for categorization.

- **[Color Accessibility Convention](../../conventions/formatting/color-accessibility.md)**: Agent color categorization (blue/green/yellow/purple) uses verified accessible palette for visual identification while maintaining text-based accessibility.

- **[Timestamp Format Convention](../../conventions/formatting/timestamp.md)**: Defines UTC+7 timestamp format (YYYY-MM-DD--HH-MM) for audit reports and validation workflows.

## Agent File Structure

### Required Frontmatter

Every agent file MUST begin with YAML frontmatter containing six required fields:

```yaml
---
name: agent-name
description: Expert in X specializing in Y. Use when Z.
tools: Read, Glob, Grep
model: inherit
color: blue
skills: []
---
```

**Format Note**: This example shows **Claude Code format** (`.claude/agents/`). The equivalent **OpenCode format** (`.opencode/agent/`) uses boolean flags for tools: `tools: { read: true, glob: true, grep: true }` and model references like `model: zai/glm-4.7` or `model: inherit`.

**Field Order**: Fields MUST appear in this exact order (name, description, tools, model, color, skills) for consistency and grep-ability across all agents.

**NO Comments in Frontmatter**: Agent frontmatter MUST NOT contain inline comments (# symbols in YAML). Research shows OpenCodehas frontmatter parsing issues (GitHub issue #6377), and best practice for configuration files is to keep YAML clean without inline comments. Put explanations in the document body below the frontmatter code block, not as inline comments.

**Field Definitions:**

1. **`name`** (required)
   - MUST exactly match the filename (without `.md` extension)
   - Use kebab-case format
   - Should be descriptive and action-oriented
   - Examples: `doc-writer`, `repo-governance-checker`, `api-validator`

2. **`description`** (required)
   - One-line summary of when to use this agent
   - Should complete: "Use this agent when..."
   - Be specific about the agent's expertise
   - Example: `"Expert documentation writer specializing in Obsidian-optimized markdown and DiÃ¡taxis framework. Use when creating, editing, or organizing project documentation."`

3. **`tools`** (required)
   - Comma-separated list of allowed tool names
   - Explicit whitelist for security and clarity
   - Only include tools the agent needs
   - Common tools: `Read`, `Write`, `Edit`, `Glob`, `Grep`, `Bash`

4. **`model`** (required)
   - Specifies which model to use for this agent
   - Options: `inherit` (default), `haiku`, `sonnet`, or `opus`
   - Use `inherit` unless there's a specific need for a particular model
   - See "Model Selection Guidelines" below for decision criteria

5. **`color`** (required)
   - Visual categorization based on agent role
   - Options: `blue` (writers), `green` (checkers), `yellow` (updaters), `purple` (implementors)
   - Helps users quickly identify agent type
   - See "Agent Color Categorization" below for assignment guidelines

6. **`skills`** (required)
   - List ofSkill names the agent references (from `.claude/skills/` (primary) or `.opencode/skill/` (secondary))
   - Can be empty array `[]` if agent doesn't useSkills -Skills auto-load when agent is invoked (if task matchesSkill description)
   - Enables composability and explicit knowledge dependencies
   - Example: `skills: [color-accessibility-diagrams, maker-checker-fixer-pattern]`
   - See "AgentSkills References" section below for complete details

### Optional Frontmatter Fields

In addition to the six required fields, agents may include optional metadata fields for tracking:

1. **`created`** (optional)
   - Date when the agent was first created
   - Format: `YYYY-MM-DD` (ISO 8601 date only)
   - Example: `created: 2025-11-23`
   - Helps track agent age and history

2. **`updated`** (optional)
   - Date when the agent was last modified
   - Format: `YYYY-MM-DD` (ISO 8601 date only)
   - Example: `updated: 2025-12-03`
   - Automatically updated when significant changes are made
   - Helps identify stale or recently maintained agents

**Best Practices:**

- Use both `created` and `updated` fields together for complete tracking
- Update the `updated` field whenever making substantial changes to the agent
- Use consistent date format (YYYY-MM-DD) matching the project's [Timestamp Format Convention](../../conventions/formatting/timestamp.md) (date-only format)
- Place these fields after the six required fields in frontmatter
- These fields align with documentation frontmatter best practices from Hugo, Jekyll, and Front Matter CMS

**Example with optional fields:**

```yaml
---
name: agent-name
description: Expert in X specializing in Y. Use when Z.
tools: Read, Glob, Grep
model: inherit
color: blue
skills: []
created: 2025-11-23
updated: 2025-12-03
---
```

### AgentSkills References

**REQUIRED FIELD**: All agents MUST include a `skills:` frontmatter field for composability and consistency.

**Purpose:** The `skills:` field declares whichSkills (knowledge packages in `.claude/skills/` (primary) or `.opencode/skill/` (secondary)) the agent leverages. This enables:

- **Composability**: Explicit declarations of knowledge dependencies
- **Consistency**: All agents follow same structure (no special cases)
- **Discoverability**: Easy to see which agents use whichSkills
- **Validation**: Checkers can enforce field presence and validate references

#### Skills Field Format

The `skills` field (already defined as field 6 in Required Frontmatter above) has the following detailed characteristics:

- **Format**: YAML array of strings
- **Required**: Yes (can be empty `[]`)
- **Values**:Skill names matching folder names in `.opencode/skill/`
- **Auto-loading**:Skills load when agent invoked AND task matchesSkill description
- **Validation**: ReferencedSkills must exist in `.claude/skills/` (primary) or `.opencode/skill/` (secondary) directory
- **Example**: `skills: [color-accessibility-diagrams, maker-checker-fixer-pattern]`

#### When to ReferenceSkills vs. Inline Knowledge

**UseSkills references when:**

- PASS: Knowledge is specialized and deep (e.g., accessible color palettes, Gherkin syntax)
- PASS: Knowledge is shared across multiple agents (e.g., Maker-Checker-Fixer pattern)
- PASS: Knowledge requires progressive disclosure (overview at startup, details on-demand)
- PASS: Knowledge is frequently updated (Skills centralize updates)
- PASS: Knowledge has multiple aspects (Skill can have reference.md, examples.md)

**Use inline knowledge when:**

- PASS: Knowledge is agent-specific and not shared
- PASS: Knowledge is simple and fits in a few paragraphs
- PASS: Knowledge is critical for agent's core operation (always needed)
- PASS: Knowledge is stable and rarely changes

#### Skills Field Examples

**Agent usingSkills:**

```yaml
---
name: docs-maker
description: Expert documentation writer specializing in Obsidian-optimized markdown and DiÃ¡taxis framework.
tools: Read, Write, Edit, Glob, Grep
model: inherit
color: blue
skills:
  - color-accessibility-diagrams
  - maker-checker-fixer-pattern
---
```

**Agent not usingSkills:**

```yaml
---
name: simple__helper
description: Simple helper agent for basic tasks.
tools: Read
model: haiku
color: green
skills: []
---
```

#### Skills Composition Pattern

Agents can reference multipleSkills that work together:

```yaml
---
name: apps-ayokoding-web-general-maker
description: Expert at creating general Hugo content for ayokoding-web (Hextra theme).
tools: Read, Write, Edit, Glob, Grep
model: sonnet
color: blue
skills:
  - hugo-ayokoding-development
  - color-accessibility-diagrams
  - factual-validation-methodology
---
```

When this agent is invoked, all threeSkills auto-load if the task description matches their triggers.Skills compose seamlessly to provide comprehensive knowledge.

#### Best Practices forSkills References

1. **Minimal set**: Reference onlySkills the agent actually uses
2. **RelevantSkills**:Skills should align with agent's domain
3. **Order by importance**: List most criticalSkills first
4. **Keep updated**: Add/removeSkills as agent evolves
5. **Validate references**: Ensure referencedSkills exist in `.opencode/skill/`

#### Skills Documentation: Frontmatter Only (DRY Principle)

**CRITICAL**:Skills MUST only be declared in frontmatter. Do NOT create documentation sections listing skills in the agent body.

**Why Frontmatter Only:**

- âœ… **Single source of truth**: Frontmatter is canonical and machine-readable
- âœ… **Eliminates duplication**: EachSkill already has its own description in SKILL.md
- âœ… **Reduces maintenance**: No risk of frontmatter and body getting out of sync
- âœ… **Keeps agents lean**: Avoids unnecessary documentation bulk
- âœ… **Follows DRY**: Don't Repeat Yourself - reference, don't restate

**FORBIDDEN Pattern** (violates DRY):

```markdown
## Knowledge Dependencies (Skills)

This agent leveragesSkills from `.claude/skills/`:

1. **`skill-name`** - what it does
2. **`other-skill`** - what it does
```

**CORRECT Pattern** (frontmatter only):

```yaml
---
skills:
  - skill-name
  - other-skill
---
```

**Contextual Inline References** (allowed when adding context):

```markdown
**See `repo-generating-validation-reports`Skill** for UUID chain generation and progressive writing methodology.
```

This is acceptable because it provides contextual guidance pointing to specificSkill knowledge at relevant points in the agent documentation.

**Summary**: Declare skills in frontmatter, optionally reference them inline for context, but NEVER create a dedicated section listing skills with descriptions.

#### Skills vs. Direct Convention References

Agents can use bothSkills AND direct links to convention documents:

- **Skills**: For progressive disclosure and shared knowledge (auto-loaded)
- **Direct links**: For specific, targeted guidance (always in Reference Documentation section)

**Example combining both:**

```yaml
---
name: docs-checker
description: Validates documentation quality and factual correctness.
tools: Read, Glob, Grep, Write, Bash
model: sonnet
color: green
skills:
  - maker-checker-fixer-pattern
  - criticality-confidence-system
---
```

**Reference Documentation section:**

```markdown
## Reference Documentation

**Skills**: This agent uses `maker-checker-fixer-pattern` and `criticality-confidence-system`Skills for validation workflows.

**Conventions:**

- `governance/conventions/writing/quality.md` - Content Quality Principles
- `governance/conventions/formatting/linking.md` - Linking Convention
```

This pattern provides both auto-loaded knowledge (Skills) and explicit references for specific requirements.

See [Skills README](../../../.claude/skills/README.md) for complete details onSkills creation, structure, and usage patterns.

### Document Structure

After frontmatter, agents should follow this structure:

```markdown
# [Agent Name] Agent

[One-paragraph introduction describing the agent's role]

## Core Expertise / Core Responsibility

[Clear statement of the agent's primary purpose and capabilities]

## [Domain-Specific Sections]

[Detailed guidelines, standards, checklists, examples specific to this agent]

## Reference Documentation

[Links to AGENTS.md, conventions, and related documentation]
```

**Required Sections:**

1. **Title (H1)**: Must follow pattern `# [Name] Agent`
2. **Core Expertise/Responsibility (H2)**: Clear purpose statement
3. **Reference Documentation (H2)**: Links to relevant conventions and guidance

**Optional Sections:**

- Detailed guidelines
- Examples and anti-patterns
- Checklists
- Decision trees
- Troubleshooting

## Agent Naming Conventions

### File Naming

Agent files follow kebab-case naming with **optional scope prefixes** for app-specific or lib-specific agents:

**Pattern**: `[scope__]agent-name.md`

Where:

- `scope` (optional): `apps-[app-name]-`, `libs-[lib-name]-`, or `apps-labs-[app-name]-`
- `agent-name`: descriptive kebab-case identifier

```
PASS: Good - General agents (no scope prefix):
- docs-maker.md
- repo-governance-checker.md
- plan-executor.md
- readme-maker.md

PASS: Good - App-scoped agents:
- apps-ayokoding-web-general-maker.md
- apps-ayokoding-web-by-example-checker.md
- apps-oseplatform-web-content-maker.md
- apps-oseplatform-web-deployer.md

PASS: Good - Lib-scoped agents (future):
- libs__ts-auth__validator.md
- libs__ts-payment__checker.md

PASS: Good - Apps-labs scoped agents (future):
- apps-labs__prototype-x__tester.md

FAIL: Bad:
- DocWriter.md (PascalCase)
- doc_writer.md (snake_case)
- documentation-writer-agent.md (redundant suffix)
- ayokoding-general-maker.md (missing scope delimiter)
- apps_ayokoding-web_general-maker.md (wrong delimiter - use hyphens)
```

### Scope Prefix Guidelines

**When to use scope prefixes:**

1. **`apps-[app-name]-`** - Agent works ONLY with a specific app
   - Content creation for Hugo sites (ayokoding-web, oseplatform-web)
   - App-specific validation, deployment, structure management
   - Examples: `apps-ayokoding-web-general-maker`, `apps-oseplatform-web-deployer`

2. **`libs-[lib-name]-`** - Agent works ONLY with a specific library
   - Future use when monorepo has libraries with specific agents
   - Library-specific validation, testing, documentation
   - Examples: `libs-ts-auth-validator`, `libs-ts-payment-checker`

3. **`apps-labs-[app-name]-`** - Agent works with experimental apps
   - Future use for prototype-specific agents
   - Experimental validation, testing workflows
   - Examples: `apps-labs-prototype-x-tester`

**When NOT to use scope prefixes:**

- **General-purpose agents**: Work across entire repository (docs-maker, repo-governance-checker, plan-executor)
- **Cross-cutting agents**: Apply to multiple apps/libs (readme-maker, agent-maker, repo-workflow-maker)
- **Meta-agents**: Manage repository structure (docs-file-manager, repo-governance-maker)

**Scope naming rules:**

- App/lib names must match directory names exactly (e.g., `ayokoding-web` matches `apps/ayokoding-web/`)
- Use kebab-case throughout (no camelCase, PascalCase, or snake_case)
- Hyphens `-` separate all parts of the agent name (consistent kebab-case throughout)
- Agent name after scope uses standard kebab-case patterns

### Naming Guidelines

1. **Be descriptive** - Name should indicate the agent's purpose
2. **Be concise** - Avoid unnecessary words
3. **Be action-oriented** - Use verbs when appropriate (`maker`, `checker`, `validator`, `fixer`, `deployer`)
4. **Avoid redundancy** - Don't add `-agent` suffix (implied by location)
5. **Match frontmatter** - `name` field must match filename exactly (including scope prefix)
6. **Use scope when appropriate** - Add `apps-[app-name]-` prefix for app-specific agents

### Agent Name vs Description

- **Name**: Short identifier used in file system and frontmatter (includes scope prefix if applicable)
- **Description**: Detailed explanation of when and how to use

Example - General agent:

```yaml
name: docs-maker # Short, kebab-case, no scope (general-purpose)
description: Expert documentation writer specializing in Obsidian-optimized markdown and DiÃ¡taxis framework. Use when creating, editing, or organizing project documentation. # Detailed usage guidance
```

Example - App-scoped agent:

```yaml
name: apps-ayokoding-web-general-maker # Includes scope prefix
description: Expert at creating general Hugo content for ayokoding-web (Hextra theme) following Hugo Content Convention and Content Quality Principles. # Detailed usage guidance
```

## Tool Access Patterns

Tool permissions follow the **principle of least privilege**: agents should only have access to tools they actually need.

| Pattern           | Tools                               | Use For                                       | Example                 | Rationale                                                          |
| ----------------- | ----------------------------------- | --------------------------------------------- | ----------------------- | ------------------------------------------------------------------ |
| **Read-Only**     | Read, Glob, Grep                    | Analysis without reports                      | (none currently)        | Pure read operations without file output                           |
| **Checker**       | Read, Glob, Grep, Write, Bash       | Validation with audit report generation       | repo-governance-checker | Needs Write for reports in generated-reports/, Bash for timestamps |
| **Documentation** | Read, Write, Edit, Glob, Grep       | Creating/editing docs, managing doc structure | doc-writer              | Needs file creation/editing but no shell access                    |
| **Development**   | Read, Write, Edit, Glob, Grep, Bash | Code generation, tests, builds, deployment    | test-runner             | Requires command execution (powerful, only when necessary)         |

### Report-Generating Agents: Mandatory Tool Requirements

**CRITICAL RULE**: Any agent that writes to `generated-reports/` directory MUST have **both Write and Bash** tools in their frontmatter.

**Tool Requirements Explained**:

- **Write tool**: Required for creating report files in `generated-reports/`
- **Bash tool**: Required for generating UTC+7 timestamps for report filenames using `TZ='Asia/Jakarta' date +"%Y-%m-%d--%H-%M"`

**Why both are mandatory**:

1. **Write** - Creates the actual report file
2. **Bash** - Generates accurate, real-time timestamps (placeholder timestamps like "00-00" are forbidden)

**Applies to these agent types**:

- All `*-checker` agents (repo-governance-checker, docs-checker, plan-checker, plan-execution-checker, etc.)
- `repo-governance-fixer` (generates fix reports)
- Any agent creating validation, audit, or verification reports

**MANDATORY REQUIREMENT FOR ALL \*-CHECKER AGENTS**:

ALL checker agents MUST write their validation/audit reports to `generated-reports/` directory. This is a hard requirement with NO EXCEPTIONS. The following checker agents are subject to this rule:

1. repo-governance-checker
2. apps-ayokoding-web-general-checker
3. apps-ayokoding-web-by-example-checker
4. apps-ayokoding-web-facts-checker
5. apps-ayokoding-web-link-checker
6. apps-ayokoding-web-structure-checker
7. apps-oseplatform-web-content-checker
8. docs-checker
9. docs-tutorial-checker
10. readme-checker
11. plan-checker
12. plan-execution-checker

**NO conversation-only output**: Checker agents MUST NOT output validation results in conversation only. All validation findings MUST be written to audit report files following the 4-part pattern `{agent-family}__{uuid-chain}__{YYYY-MM-DD--HH-MM}__audit.md`. The UUID chain enables parallel execution without file collisions.

**PROGRESSIVE WRITING REQUIREMENT**:

**CRITICAL BEHAVIORAL REQUIREMENT**: ALL \*-checker agents MUST write reports PROGRESSIVELY (continuously updating files during execution), NOT buffering findings in memory to write once at the end.

**Why this is mandatory:**

- **Context compaction survival**: During long audits, Claude Code may compact/summarize conversation context. If agent only writes at the END, file contents may be lost during compaction.
- **Real-time persistence**: File continuously updated THROUGHOUT execution ensures findings persist regardless of context compaction.
- **Behavioral, not optional**: This is a hard requirement for all checker agents.

**Implementation requirement:**

1. **Initialize file at execution start** - Create report file with header and "In Progress" status immediately
2. **Write findings progressively** - Each validated item written to file immediately after checking (not buffered)
3. **Update continuously** - Progress indicator and running totals updated throughout execution
4. **Finalize on completion** - Update status to "Complete" with final summary statistics

See [Temporary Files Convention - Progressive Writing Requirement](../infra/temporary-files.md#progressive-writing-requirement-for-checker-agents) for complete details, patterns, and examples.

**Example frontmatter**:

```yaml
---
name: repo-governance-checker
description: Validates consistency between agents, AGENTS.md, conventions, and documentation.
tools: Read, Glob, Grep, Write, Bash
model: sonnet
color: green
---
```

**Verification**: When creating or updating report-generating agents, verify both Write and Bash are present in the tools list.

See [Temporary Files Convention](../infra/temporary-files.md) for complete details on report naming patterns, mandatory checker requirements, and timestamp generation.

### Writing to .opencode/ Folders

**CRITICAL RULE**: When creating or modifying files in `.claude/` folders (especially `.claude/agents/`) or `.opencode/` folders (especially `.opencode/agent/`), agents MUST use Bash tools (heredoc, sed, awk, etc.) and NOT Write/Edit tools.

**Rationale**: Bash tools allow autonomous agent operation without requiring user approval for file operations. Write/Edit tools trigger user approval prompts, breaking autonomous workflows.

**Applies to**:

- Creating new agent files in `.claude/agents/` or `.opencode/agent/`
- Updating existing agent files in `.claude/agents/` or `.opencode/agent/`
- Modifying `.claude/agents/README.md` or `.opencode/agent/README.md`
- Any other `.opencode/` folder operations

**Tool patterns**:

```bash
# Create new agent file (heredoc pattern)
cat > .claude/agents/new-agent.md <<'END_HEREDOC'
---
name: new-agent
description: Agent description here
tools: Read, Glob, Grep, Bash
model: inherit
color: blue
---

# Agent content here...
END_HEREDOC

# Update existing agent file (sed/awk pattern)
sed -i '/^model:/s/inherit/sonnet/' .claude/agents/agent-name.md

# Update README.md (targeted insertion)
awk 'pattern { insert_text } { print }' .claude/agents/README.md > temp && mv temp .claude/agents/README.md
```

**Agents affected**:

- `agent-maker` - Creates new agents, already complies
- `repo-governance-maker` - Updates agents, already complies

**Verification**: Check that agents writing to `.opencode/` use only Bash tool (not Write/Edit).

## Model Selection Guidelines

**Default**: Use `inherit` unless specific model capabilities are required.

### Model Selection Decision Tree

```
Start: Choosing Agent Model
    â”‚
    â”œâ”€ Does this agent require specific model capabilities?
    â”‚   â”‚
    â”‚   â”œâ”€ No â†’ Use `model: inherit`
    â”‚   â”‚        (Most agents should use inherit)
    â”‚   â”‚
    â”‚   â””â”€ Yes â†’ What specific capability?
    â”‚              â”‚
    â”‚              â”œâ”€ Simple, straightforward tasks â†’ `model: haiku`
    â”‚              â”‚   (Pattern matching, URL validation, file checks)
    â”‚              â”‚
    â”‚              â”œâ”€ Advanced reasoning/deep analysis â†’ `model: sonnet`
    â”‚              â”‚   (Complex validation, cascading impacts, multi-step orchestration)
    â”‚              â”‚
    â”‚              â”œâ”€ Multi-step planning and strategy â†’ `model: sonnet`
    â”‚              â”‚
    â”‚              â””â”€ Unsure â†’ Use `model: inherit`
    â”‚                         (Can always change later)
```

**Important**: Document your reasoning if using a specific model. Add a comment in the agent explaining why.

## Agent Color Categorization

### Color Field (Required)

The `color` frontmatter field provides visual categorization for agents based on their **primary role**. This helps users quickly identify agent types and understand their capabilities at a glance.

**Format:**

```yaml
---
name: agent-name
description: Expert in X specializing in Y. Use when Z.
tools: Read, Glob, Grep
model: inherit
color: blue
---
```

**Field Definition:**

- **`color`** (required)
  - Values: `blue`, `green`, `yellow`, `purple`
  - Indicates the agent's primary role category
  - Used for visual identification in agent listings
  - Helps users choose the right agent type

### Color-to-Role Mapping

Agents are categorized by their **primary role** which aligns with naming suffixes and tool permissions:

| Color         | Role             | Purpose                               | Tool Pattern                            | Agents                                                                                       |
| ------------- | ---------------- | ------------------------------------- | --------------------------------------- | -------------------------------------------------------------------------------------------- |
| ðŸŸ¦ **Blue**   | **Writers**      | Create new content from scratch       | Has `Write` tool                        | docs-maker<br>plan-maker<br>docs-tutorial-maker                                              |
| ðŸŸ© **Green**  | **Checkers**     | Validate and generate reports         | Has `Write`, `Bash` (no `Edit`)         | repo-governance-checker<br>plan-checker<br>docs-checker                                      |
| ðŸŸ¨ **Yellow** | **Updaters**     | Modify and propagate existing content | Has `Edit` (usually not `Write`)\*      | repo-governance-maker\*<br>docs-file-manager                                                 |
| ðŸŸª **Purple** | **Implementors** | Execute plans with full tool access   | Has `Write`, `Edit`, `Bash` (or Bash)\* | plan-executor<br>docs-link-general-checker<br>apps-ayokoding-web-link-checker<br>deployers\* |

**Edge Case Notes:**

- **\*Yellow with Write**: repo-governance-maker needs Write tool to create new convention files (not just edit existing). Documented exception.
- **\*Purple Bash-only**: Deployers (ayokoding-web-deployer, oseplatform-web-deployer) only need Bash for git/deployment orchestration. Purple without Write/Edit is valid for Bash-only orchestrators.

**Color Accessibility Note**: All four colors (blue, green, yellow, purple) are from the verified accessible palette defined in [Color Accessibility Convention](../../conventions/formatting/color-accessibility.md) - the master reference for all color usage in this repository. These colors meet WCAG AA standards for both light and dark modes and work for all types of color blindness (protanopia, deuteranopia, and tritanopia). See the accessibility section below for details on how agents are identified beyond color. All color-related work must reference the Color Accessibility Convention as the authoritative source.

### Why This Categorization System

This role-based categorization was chosen because it:

1. **Aligns with naming conventions** - Role suffixes (-writer, -checker, -updater, -implementor) directly map to colors
2. **Maps to tool permissions** - Clear security boundaries between read-only, edit-only, write-capable, and full-access agents
3. **Provides clear user guidance** - Users can quickly identify which category of agent they need
4. **Extensible** - New agents naturally fit into one of the four role categories
5. **Semantic consistency** - Colored square emojis (ðŸŸ¦ðŸŸ©ðŸŸ¨ðŸŸª) have no pre-existing meaning in Unicode, allowing flexible assignment

### Hybrid Agents Exception

**DOCUMENTED EXCEPTION**: Link checker agents are hybrid agents that combine validation (green) with state management (purple). This is an explicit exception to the standard color-to-role mapping.

**Hybrid Link Checkers:**

- **docs-link-general-checker** - Validates documentation links + manages external-links-status.yaml cache
- **apps-ayokoding-web-link-checker** - Validates Hugo content links + manages ayokoding-links-status.yaml cache

**Why hybrid status?**

1. **Primary role**: Link validation (checker behavior) with audit report generation
2. **State management**: Maintain persistent cache files tracking external link health over time
3. **Tool requirements**: Write tool needed ONLY for cache file management (not general content modification)
4. **Color assignment**: `purple` reflects the hybrid nature (validation + state management)

**Rationale for Write tool access:**

- Cache files (`external-links-status.yaml`, `ayokoding-links-status.yaml`) are operational metadata, NOT temporary reports
- Cache management is essential functionality, NOT general file writing capability
- Write tool is scoped specifically to designated cache file paths (explicit over implicit)
- This exception respects the Explicit Over Implicit principle by documenting the hybrid role

**Cache files are NOT temporary:**

- Location: `docs/metadata/` (docs-link-general-checker) and `apps/ayokoding-web/` (apps-ayokoding-web-link-checker)
- Purpose: Long-term link status tracking (6-month expiry), shared across team
- Committed to git: Yes (operational metadata)
- Updated every run: Yes (including lastFullScan timestamp)

This hybrid status is intentionally documented here to maintain transparency and prevent confusion about tool permission patterns.

### Assigning Colors to New Agents

When creating a new agent, assign a color based on its **primary capability**:

**Decision Tree:**

```
Start: What is the agent's primary capability?
    â”‚
    â”œâ”€ Creates new files/content from scratch
    â”‚   â””â”€> color: blue (Writer)
    â”‚       - Must have `Write` tool
    â”‚       - Examples: docs-writer, plan-writer
    â”‚
    â”œâ”€ Validates/checks and generates reports
    â”‚   â””â”€> color: green (Checker)
    â”‚       - Has `Write`, `Bash` (no Edit)
    â”‚       - Write needed for audit reports in generated-reports/
    â”‚       - Bash needed for UTC+7 timestamps
    â”‚       - Examples: repo-governance-checker, plan-checker, docs-checker
    â”‚       - EXCEPTION: Link checkers use purple (see Hybrid Agents above)
    â”‚
    â”œâ”€ Modifies/updates existing content only
    â”‚   â””â”€> color: yellow (Updater)
    â”‚       - Has `Edit` but NOT `Write`
    â”‚       - Examples: repo-governance-maker, docs-file-manager
    â”‚
    â””â”€ Executes plans/orchestrates tasks
        â””â”€> color: purple (Implementor)
            - Has Write, Edit, AND Bash
            - Examples: plan-executor
            - INCLUDES: Hybrid link checkers (validation + state management)
```

**Edge Cases:**

- **Agent has both Write and Edit**: Choose based on primary purpose
  - If mainly creates new content â†’ `blue` (Writer)
  - If mainly executes plans/tasks â†’ `purple` (Implementor)
- **Link-checkers with Write, Edit, Bash**: Use `purple` (Implementor)
  - Write tool needed for cache file updates (external-links-status.yaml)
  - Edit tool needed for fixing broken links in content
  - Bash tool needed for UTC+7 timestamps
  - Examples: docs-link-general-checker, apps-ayokoding-web-link-checker
- **Deployers with Bash only**: Use `purple` (Implementor)
  - Execute deployment orchestration (purple's "executes plans/orchestrates tasks")
  - Don't create or edit files, only run git/deployment commands
  - Edge case: purple without Write/Edit tools (Bash-only orchestration)
  - Examples: ayokoding-web-deployer, oseplatform-web-deployer
- **Updaters with Write tool**: Investigate actual usage
  - Yellow (Updaters) should have Edit but NOT Write
  - If Write is needed for creating new convention files â†’ keep yellow, document exception
  - If Write can be removed â†’ remove Write to match yellow categorization
  - Example: repo-governance-maker (creates new conventions, keeps Write + Edit)
- **Agent doesn't fit any category**: Consider if it should be split or if a new category is needed
- **Unsure**: Default to the most restrictive category based on tools, or omit the color field

**Accessibility Note**: All assigned colors (blue, green, yellow, purple) are verified color-blind friendly and meet WCAG accessibility standards per the [Color Accessibility Convention](../../conventions/formatting/color-accessibility.md). Agents should still be identified primarily by name and role suffix, not color alone, to ensure accessibility for all users. See the Color Accessibility Convention for complete details on palette verification, testing methodology, and WCAG compliance.

### Color Accessibility for Agent Identification

**CRITICAL**: Colored square emojis (ðŸŸ¦ðŸŸ©ðŸŸ¨ðŸŸª) provide visual categorization but are SUPPLEMENTARY to semantic information. Agents must be identifiable without relying on color perception.

#### Multiple Identification Methods

Agents are identified through FIVE independent methods:

| Identification Method | Example                          | Purpose                                   |
| --------------------- | -------------------------------- | ----------------------------------------- |
| **Agent Name**        | "docs-maker"                     | Primary text-based identifier             |
| **Role Suffix**       | "-maker" (writer)                | Indicates category through naming pattern |
| **Emoji Shape**       | ðŸŸ¦ (square)                      | Shape differentiation (not color)         |
| **Description**       | "Expert documentation writer..." | Semantic purpose statement                |
| **Color Field**       | `color: blue`                    | Text value in frontmatter                 |

**Users with color blindness can identify agents by:**

- Reading the agent name
- Recognizing the role suffix pattern (-maker, -checker, -updater, -executor)
- Seeing that the emoji is a square (shape, not color)
- Reading the description field

**Color perception is NOT required** to use agents effectively.

#### Accessible Color Palette Verification

All agent colors are from the verified accessible palette:

| Color  | Emoji | Hex Code | WCAG AA (Light) | WCAG AA (Dark) | Safe For               |
| ------ | ----- | -------- | --------------- | -------------- | ---------------------- |
| Blue   | ðŸŸ¦    | #0173B2  | PASS: 4.88:1    | PASS: 4.30:1   | All types (excellent)  |
| Green  | ðŸŸ©    | #029E73  | PASS: 4.67:1    | PASS: 4.50:1   | All types (good)       |
| Yellow | ðŸŸ¨    | #F1C40F  | 3.51:1          | 2.99:1         | All types (moderate)\* |
| Purple | ðŸŸª    | #CC78BC  | PASS: 3.65:1    | PASS: 5.74:1   | All types (moderate)   |

\*Yellow emoji (#F1C40F) has slightly lower contrast but remains distinguishable because it's combined with:

- Square shape (not relying on color alone)
- Text label "Updater"
- Role suffix "-updater"

**Source**: Verified through ColorBrewer2, Paul Tol's schemes, and WCAG testing. See [Color Accessibility Convention](../../conventions/formatting/color-accessibility.md) - the master reference for all color usage - for complete palette details, scientific verification sources, testing methodology, and WCAG compliance standards.

#### Why These Colors Were Chosen

1. **Protanopia & Deuteranopia (red-green blindness)**: Blue, yellow, and purple remain distinct. We avoid red and green entirely.
2. **Tritanopia (blue-yellow blindness)**: Blue appears pink, yellow appears light pink, but shape and text differentiation ensure identification.
3. **WCAG AA Compliance**: All colors meet minimum contrast requirements against both light and dark backgrounds.
4. **Cross-Platform Consistency**: Colors render consistently across GitHub, Obsidian, VS Code, and terminals.

#### Agent Identification Example

**Example agent: `docs-maker`**

```yaml
---
name: docs-maker
description: Expert documentation writer specializing in Obsidian-optimized markdown and DiÃ¡taxis framework. Use when creating, editing, or organizing project documentation.
tools: Read, Write, Edit, Glob, Grep
model: inherit
color: blue
---
```

**How users identify this agent (without seeing color):**

1. **Name**: "docs-maker" (text identifier)
2. **Suffix**: "-maker" implies writer/creator role
3. **Description**: "Expert documentation writer" (semantic identifier)
4. **Emoji**: ðŸŸ¦ appears as a square (shape), regardless of color perception
5. **Field**: `color: blue` is a text value in YAML

**For users with protanopia/deuteranopia**: The blue square appears as a distinct shade but is identifiable by its square shape and accompanying text.

**For users with tritanopia**: The blue square appears pinkish but is identifiable by its square shape and accompanying text.

**For users with complete color blindness (achromatopsia)**: All squares appear as different shades of gray but are identifiable by their position next to agent names and descriptions.

### Using Colors in Documentation

**Agent README Listings:**

When listing agents in `.claude/agents/README.md` (or `.opencode/agent/README.md`), use the colored square emoji:

```markdown
### ðŸŸ¦ `docs-writer.md`

Expert documentation writer specializing in Obsidian-optimized markdown and DiÃ¡taxis framework.
```

**Consistency with Emoji Convention:**

Colored square emojis follow the [Emoji Usage Convention](../../conventions/formatting/emoji.md):

- Use at the start of headings for visual categorization
- Maintain semantic consistency (same color = same role across all docs)
- Avoid overuse (1 emoji per agent listing)

### Color Field Examples

**Writer Agent (Blue):**

```yaml
---
name: docs-writer
description: Expert documentation writer specializing in Obsidian-optimized markdown and DiÃ¡taxis framework. Use when creating, editing, or organizing project documentation.
tools: Read, Write, Edit, Glob, Grep
model: inherit
color: blue
---
```

**Checker Agent (Green):**

```yaml
---
name: repo-governance-checker
description: Validates consistency between agents, AGENTS.md, conventions, and documentation. Use when checking for inconsistencies, contradictions, duplicate content, or verifying repository rule compliance.
tools: Read, Glob, Grep, Write, Bash
model: sonnet
color: green
---
```

**Updater Agent (Yellow):**

```yaml
---
name: repo-governance-maker
description: Propagates rule and convention changes across AGENTS.md, convention docs, agents, and indices. Use when adding/modifying rules, conventions, or standards that affect multiple files.
tools: Read, Edit, Glob, Grep
model: sonnet
color: yellow
---
```

**Implementor Agent (Purple):**

```yaml
---
name: plan-executor
description: Expert at systematically implementing project plans by following delivery checklists. Reads plans from plans/ directory, executes implementation steps, runs validation, and updates checklist progress with detailed notes. Use when executing a plan created by the plan-maker agent.
tools: Read, Write, Edit, Glob, Grep, Bash
model: sonnet
color: purple
---
```

## Agent Responsibility Boundaries

### Single Responsibility Principle

Each agent should have **one clear, focused purpose**.

**PASS: Good - Single Responsibility:**

```yaml
name: doc-writer
description: Expert documentation writer specializing in Obsidian-optimized markdown and DiÃ¡taxis framework. Use when creating, editing, or organizing project documentation.
```

**FAIL: Bad - Multiple Responsibilities:**

```yaml
name: doc-and-code-helper
description: Writes documentation, generates code, runs tests, and deploys applications.
```

### Avoiding Overlap

Before creating a new agent, check if existing agents already cover the domain:

1. **Review** `.opencode/agent/` directory
2. **Check** each agent's `description` field
3. **Consider** if you can extend an existing agent
4. **Create new** only if there's no overlap

**Decision Matrix: New Agent vs Extend Existing**

| Scenario                     | Create New Agent | Extend Existing Agent  |
| ---------------------------- | ---------------- | ---------------------- |
| Completely different domain  | PASS: Yes        | FAIL: No               |
| Different tool requirements  | PASS: Yes        | FAIL: No               |
| Different model needs        | PASS: Yes        | FAIL: No               |
| Slight variation in workflow | FAIL: No         | PASS: Yes              |
| Similar expertise area       | FAIL: No         | PASS: Yes              |
| Experimental/temporary       | Maybe            | PASS: Prefer extending |

### Agent Specialization vs Generalization

**Prefer specialization over generalization.**

**PASS: Good - Specialized Agents:**

- `doc-writer` - Documentation only
- `repo-governance-checker` - Consistency validation only
- `test-runner` - Test execution only

**FAIL: Bad - Over-Generalized:**

- `helper` - Too vague, unclear purpose
- `assistant` - No specific expertise
- `general-agent` - Defeats the purpose of specialization

## Agent Invocation Patterns

Agents can be invoked in two ways, each with different implications for file persistence and execution context.

### Pattern 1: Task Tool Invocation (Isolated Context)

**Use When**: Agent performs analysis, research, or information gathering without needing to persist file changes.

**Characteristics**:

- Agent runs in isolated subprocess context
- File operations (Write, Edit) don't persist to actual filesystem
- Results returned to main conversation only
- Suitable for read-only operations

**Example Use Cases**:

- Code exploration and understanding
- Research tasks (WebSearch + analysis)
- Answering questions about codebase
- Planning without implementation
- Information gathering
- Recommendations and suggestions

**Invocation**:

```
Task(agent-name, "analyze codebase structure")
```

**Limitation**: FAIL: File changes don't persist - Write/Edit operations stay in isolated context

### Pattern 2: Direct Execution (Main Context)

**Use When**: Agent must persist file changes (Write, Edit operations) or workflow requires file modification.

**Characteristics**:

- Logic executes in main Claude instance context
- File operations persist to actual filesystem
- Changes visible in `git status`
- Required for workflows with validation-fixing loops

**Example Use Cases**:

- Checker agents (Write audit reports to generated-reports/)
- Fixer agents (Edit files to apply fixes, Write fix reports)
- Maker agents (Write/Edit content files)
- Workflows requiring iteration (check â†’ fix â†’ check loops)
- Any operation requiring git-committable changes

**Execution Pattern**:

```
User: "Run [agent-name] logic for [scope]"

Claude: [Executes agent logic directly]
1. Uses Read tools to analyze
2. Uses Write/Edit tools to modify files
3. Changes persist to filesystem
4. User can see changes in git status
```

**Requirement**: PASS: File changes persist - all Write/Edit operations affect real files

### Decision Matrix: Which Pattern to Use?

| Agent Type                                | Needs File Persistence? | Use Pattern      | Invocation                 |
| ----------------------------------------- | ----------------------- | ---------------- | -------------------------- |
| **Exploration** (Explore agent)           | FAIL: No                | Task tool        | `Task(Explore, "find X")`  |
| **Research** (analysis only)              | FAIL: No                | Task tool        | `Task(agent, "analyze Y")` |
| **Checker** (writes audit reports)        | PASS: Yes               | Direct execution | Execute checker logic      |
| **Fixer** (applies fixes, writes reports) | PASS: Yes               | Direct execution | Execute fixer logic        |
| **Maker** (creates/updates content)       | PASS: Yes               | Direct execution | Execute maker logic        |
| **Deployer** (modifies configs)           | PASS: Yes               | Direct execution | Execute deployer logic     |
| **Workflow** (iterative check-fix)        | PASS: Yes               | Direct execution | Manual orchestration       |

### Workflows Require Direct Execution

**Critical**: Workflows orchestrating multiple agents (checker â†’ fixer loops) MUST use direct execution pattern.

**Why**: Workflows need to:

- Persist audit reports for user review
- Apply real fixes to files
- Generate fix reports
- Allow git commit of changes

**See**: [Workflow Execution Modes Convention](../../workflows/meta/execution-modes.md) for complete workflow execution patterns.

### Current Limitation: Task Tool Isolation

**Fundamental Issue**: The Task tool runs agents in isolated subprocesses where file operations don't persist to the actual filesystem.

**Impact**:

- FAIL: Audit reports written by checker agents don't appear in generated-reports/
- FAIL: Fixes applied by fixer agents don't modify actual files
- FAIL: Changes aren't visible in `git status`
- FAIL: Workflows requiring file persistence cannot use Task tool

**Workaround**: Use direct execution pattern for agents requiring file persistence.

**Future**: When workflow runner is implemented, it will orchestrate agents in main context with full file persistence.

### Examples

**FAIL: Wrong - Using Task Tool for Fixer**:

```
Task(plan-fixer, "apply fixes from audit report")
â†’ Fixes applied in isolated context
â†’ Real plan files unchanged
â†’ git status shows nothing
```

**PASS: Right - Direct Execution for Fixer**:

```
User: "Apply plan fixes in manual mode"
â†’ Execute plan-fixer logic directly
â†’ Edit tool modifies real plan files
â†’ Write tool creates real fix report
â†’ git status shows modified files
```

**PASS: Right - Using Task Tool for Research**:

```
Task(Explore, "find authentication code")
â†’ Analysis in isolated context (OK)
â†’ No file modifications needed
â†’ Results returned in conversation
```

## Convention Referencing Standards

### Required Section: Reference Documentation

**Every agent MUST include a "Reference Documentation" section** at the end. See the [Agent Creation Template](#agent-creation-template) below for the complete format.

### Reference Categories

Organize references into clear categories:

1. **Project Guidance** - Always reference `AGENTS.md`
2. **Agent Conventions** - Always reference this document (`ex-de__ai-agents.md`)
3. **Domain-Specific Conventions** - Reference relevant conventions
4. **Related Agents** - Cross-reference complementary agents

### Link Format

Use GitHub-compatible markdown with relative paths:

```markdown
PASS: Good:

- `governance/development/agents/ai-agents.md` - AI agents convention

FAIL: Bad:

- [[ex-de__ai-agents]] - Obsidian wiki link (not GitHub compatible)
- `/governance/development/agents/ai-agents.md` - Absolute path
- `governance/development/agents/ai-agents` - Missing .md extension
```

See [Linking Convention](../../conventions/formatting/linking.md) for details.

## Agent File Size Standards

### Size Limits by Agent Complexity

Agent files are organized into **three complexity tiers** with corresponding size guidelines. These limits balance agent capability with performance, maintainability, and clarity.

**Rationale**: Research shows LLMs follow ~150-200 instructions reliably, with quality degrading as count increases. While agents are only loaded when spawned (unlike AGENTS.md which is universally included), keeping them focused improves effectiveness.

#### Tier 1: Simple Agents (Deployers, Specialized Operations)

**Target**: < 500 lines / < 15KB
**Warning**: 600 lines / 18KB
**Hard Limit**: 800 lines / 25KB

**Characteristics**:

- Single, straightforward responsibility
- Minimal decision logic
- Limited tool usage (typically Bash only for deployers)
- Few edge cases to handle
- Direct, linear workflows

**Examples**:

- ayokoding-web-deployer (deployment automation)
- oseplatform-web-deployer (deployment automation)

**When to use this tier**:

- Agent performs one specific operation repeatedly
- Minimal validation or error handling needed
- Clear success/failure conditions
- No complex orchestration

#### Tier 2: Standard Agents (Makers, Checkers, Validators)

**Target**: < 800 lines / < 25KB
**Warning**: 1,000 lines / 30KB
**Hard Limit**: 1,200 lines / 35KB

**Characteristics**:

- Moderate complexity with clear domain
- Multiple related responsibilities
- Comprehensive validation or creation logic
- Moderate edge case handling
- Structured workflows with phases

**Examples**:

- docs-maker (documentation creation)
- docs-checker (factual verification)
- docs-tutorial-checker (tutorial quality validation)
- agent-maker (agent creation automation)
- apps-ayokoding-web-general-maker (general Hugo content creation)
- apps-ayokoding-web-by-example-maker (by-example tutorial creation)
- apps-oseplatform-web-content-maker (Hugo content creation)

**When to use this tier**:

- Agent creates or validates content
- Requires moderate decision-making
- Follows established patterns
- Handles multiple related tasks within a domain

#### Tier 3: Complex Agents (Planners, Orchestrators, Comprehensive Validators)

**Target**: < 1,200 lines / < 35KB
**Warning**: 1,500 lines / 40KB
**Hard Limit**: 1,800 lines / 50KB

**Characteristics**:

- High complexity with multiple interconnected concerns
- Advanced reasoning and pattern recognition
- Multi-step orchestration
- Extensive edge case handling
- Complex validation or planning logic
- Cross-cutting concerns

**Examples**:

- plan-maker (comprehensive project planning)
- plan-executor (multi-phase implementation)
- plan-checker (pre-implementation validation)
- repo-governance-maker (cascading updates across files)
- repo-governance-checker (comprehensive consistency validation)
- docs-file-manager (prefix calculation, link updates, git operations)
- swe-hugo-developer (theme development, asset pipeline, configuration)
- docs-link-general-checker (external/internal link validation with caching)

**When to use this tier**:

- Agent orchestrates multiple phases or agents
- Requires advanced reasoning
- Handles complex dependencies
- Manages cascading impacts
- Performs comprehensive validation

### Agent Categorization Reference

Quick categorization for existing agents:

| Tier                 | Agents                                                                                                                                                                                                                                                                                                                                      |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Tier 1: Simple**   | ayokoding-web-deployer, oseplatform-web-deployer                                                                                                                                                                                                                                                                                            |
| **Tier 2: Standard** | docs-maker, docs-tutorial-maker, docs-checker, docs-tutorial-checker, readme-maker, readme-checker, agent-maker, apps-ayokoding-web-general-maker, apps-ayokoding-web-by-example-maker, apps-ayokoding-web-general-checker, apps-ayokoding-web-by-example-checker, apps-oseplatform-web-content-maker, apps-oseplatform-web-content-checker |
| **Tier 3: Complex**  | plan-maker, plan-executor, plan-checker, plan-execution-checker, repo-governance-maker, repo-governance-checker, docs-file-manager, swe-hugo-developer, docs-link-general-checker                                                                                                                                                           |

### When to Condense or Split Agents

**Warning Signs (approaching limits)**:

- Agent approaching warning threshold for its tier
- Agent has multiple unrelated responsibilities
- Documentation becoming hard to navigate
- Users confused about when to use the agent

**Condensation Strategies**:

1. **Move details to conventions OR development docs (PRIMARY STRATEGY)** - **CRITICAL:** MOVE content to appropriate docs, NOT DELETE.

   **Destinations**:
   - `governance/conventions/` (content/format standards)
   - `governance/development/` (process/workflow standards)

   Create or expand documents with comprehensive details, then replace with brief summary + link. Zero content loss required.

2. **Remove redundant examples** - Keep 1-2 clear examples per pattern
3. **Consolidate similar sections** - Merge related guidelines
4. **Use tables instead of lists** - More compact for comparisons
5. **Remove "nice to have" guidance** - Focus on essential requirements

**When to split an agent**:

- Agent exceeds hard limit for its tier
- Agent has two clearly separable responsibilities
- Agent requires different tool sets for different tasks
- Users would benefit from specialized agents

**Example split scenarios**:

- Agent that both creates and validates â†’ Split into maker + checker
- Agent handling multiple unrelated domains â†’ Split by domain
- Agent with basic + advanced modes â†’ Split by complexity level

### Size Checking Process

**For agent-maker**:

1. After creating agent file, count lines and characters
2. Compare to tier limits based on agent type
3. Warn if approaching warning threshold
4. Suggest condensation if near limit

**For repo-governance-maker**:

1. When updating agents, check file size before/after
2. If agent crosses warning threshold, notify user
3. Suggest condensation strategies

**For all agent authors**:

1. Before committing agent changes, verify size
2. If approaching limits, review for redundancy
3. Consider moving details to convention docs
4. Link to detailed docs rather than duplicating

### Agent Content Philosophy

**Focus on single responsibility**:

- Each agent should do ONE thing well
- Complex workflows should orchestrate multiple agents
- Don't create "Swiss Army knife" agents

**Detailed but targeted prompts**:

- Provide comprehensive guidance for the agent's domain
- Don't document unrelated concerns
- Link to convention docs instead of duplicating

**Avoid duplication with convention docs**:

- Convention docs are the source of truth
- Agents should reference conventions, not repeat them
- Exception: Agent-specific applications of conventions

**Balance comprehensiveness with conciseness**:

- Include essential decision logic and examples
- Remove tangential information
- Prefer structured formats (tables, checklists) over prose

## Agent-Skill Separation

### Purpose

This section defines how to properly separate reusable knowledge (Skills) from agent-specific instructions (Agent files), ensuring maintainability, reducing duplication, and enabling effective knowledge delivery.

**Validated through**: AgentSkills Simplification pilot (2026-01-03) - docs family achieved 49.2% size reduction while maintaining 100% functionality.

### Knowledge Classification Decision Tree

When writing or updating an agent, use this decision tree to determine where content belongs:

```
Is this content reusable across 3+ agents?
â”‚
â”œâ”€ YES â†’ Move toSkill or Convention Document
â”‚   â”‚
â”‚   â”œâ”€ Is it actionable "how-to" guidance?
â”‚   â”‚   â””â”€ YES â†’ Create/updateSkill in .opencode/skill/
â”‚   â”‚       Examples: applying-content-quality, creating-accessible-diagrams
â”‚   â”‚
â”‚   â””â”€ Is it technical specification or standard?
â”‚       â””â”€ YES â†’ Create/update Convention in governance/conventions/
â”‚           Examples: Color Accessibility Convention, Mathematical Notation Convention
â”‚
â””â”€ NO â†’ Keep in Agent File
    â”‚
    â””â”€ Is it task-specific workflow, validation logic, or decision criteria?
        â””â”€ YES â†’ This is agent-specific knowledge, keep in agent
            Examples: "When to use this agent", validation workflow steps, tool usage patterns
```

### Four Separation Patterns

Based on the pilot validation, use these proven patterns when simplifying agents:

#### Pattern A: ReferenceSkill for Standards

**Use when**: Content is a universal standard that doesn't change per-agent.

**Before (in agent)**:

```markdown
## Content Quality Standards

**Active Voice Required**: Use active voice for clarity and directness.

PASS: Good: "The agent validates the content"
FAIL: Bad: "The content is validated by the agent"

**Heading Hierarchy**: Each file MUST have exactly one H1 heading.

[... 50-100 lines of standards ...]
```

**After (in agent)**:

```markdown
## Content Quality Standards

**See `docs-applying-content-quality`Skill for complete standards** on:

- Active voice requirements
- Heading hierarchy (single H1, proper nesting)
- Accessibility compliance (alt text, WCAG AA contrast)
- Professional formatting
```

**Impact**: ~50-100 lines removed per agent, zero loss of knowledge (accessible viaSkill).

#### Pattern B: Convention Link for Detailed Rules

**Use when**: Technical specifications have a single source of truth in conventions.

**Before (in agent)**:

```markdown
## Report Generation

**File Naming Pattern**: `generated-reports/{agent}__{uuid-chain}__{YYYY-MM-DD--HH-MM}__{type}.md`

**UUID Chain Generation**: 6-char hex UUIDs for parallel execution support.

- Root: `a1b2c3`
- Child: `a1b2c3.d4e5f6`
- Grandchild: `a1b2c3.d4e5f6.g7h8i9`

**Progressive Writing**: Initialize report at start, write findings immediately...

[... 100-200 lines of mechanics ...]
```

**After (in agent)**:

```markdown
## Report Generation

**MANDATORY**: Write findings PROGRESSIVELY to `generated-reports/` per [Temporary Files Convention](../infra/temporary-files.md).

**Report pattern**: `generated-reports/{agent}__{uuid-chain}__{timestamp}__{type}.md`

**UUID chain generation**: 6-char hex UUIDs for parallel execution. See convention for generation logic.

[Brief 3-5 line summary of workflow, link to convention for details]
```

**Impact**: ~100-200 lines removed per agent, convention becomes single source of truth.

#### Pattern C:Skill + Convention Hybrid

**Use when**: Complex domain requires both actionable guidance (Skill) and specifications (convention).

**Before (in agent)**:

```markdown
## Factual Validation

**Verification Workflow**:

1. Identify claim type (command, version, API)
2. Determine authoritative source...
   [... 100 lines of methodology ...]

**Source Prioritization**:

1. Official documentation
2. GitHub repositories...
   [... 50 lines of priority rules ...]

**Confidence Classifications**:

- [Verified]: Confirmed by authoritative source
- [Unverified]: Cannot verify...
  [... 50 lines of classifications ...]
```

**After (in agent)**:

```markdown
## Factual Validation

**See `docs-validating-factual-accuracy`Skill for complete methodology** covering:

- Verification workflow (claim identification â†’ source determination â†’ verification)
- Source prioritization (official docs â†’ GitHub â†’ registries â†’ standards)
- Confidence classifications ([Verified], [Unverified], [Error], [Outdated])

**Technical specs**: [Factual Validation Convention](../../conventions/writing/factual-validation.md) for confidence classification criteria.
```

**Impact**: ~150-300 lines removed per agent, best-of-both (guidance + specs) via two sources.

#### Pattern D: Retain Task-Specific Logic

**Use when**: Content is genuinely agent-specific and not reusable.

**Keep in agent**:

- Agent's core responsibility description
- Task-specific workflows ("Step 1: Discovery Phase...")
- Agent-specific tool usage patterns
- Domain-specific validation logic
- Decision criteria unique to this agent
- Examples of when/when-not to use this agent

**Examples of task-specific content**:

- `docs-maker`: File naming logic for DiÃ¡taxis categories
- `docs-checker`: What specific validations to perform
- `docs-fixer`: How to assess confidence levels for doc fixes
- `plan-executor`: Sequential implementation workflow

**Rationale**: Agents remain self-contained for their specific task while delegating reusable knowledge toSkills/Conventions.

### Guidelines for Future Agent Creation

When creating new agents:

1. **Start lean**: Write minimum viable agent with task-specific instructions only
2. **Reference early**: Link toSkills/Conventions instead of duplicating
3. **Quick reference OK**: Brief 1-3 line summaries withSkill/Convention links acceptable
4. **Scan for duplication**: Before finalizing, check if content exists in other agents (use Grep)
5. **3+ agent rule**: If same content appears in 3+ agents, extract toSkill/Convention

### Validation Checklist

Before committing agent changes:

- [ ] No content duplicatesSkills (check `.claude/skills/` (primary) or `.opencode/skill/` (secondary) catalog)
- [ ] No content duplicates Conventions (check `governance/conventions/`)
- [ ] AllSkills referenced exist in `.opencode/skill/`
- [ ] All Convention links point to valid files
- [ ] Task-specific instructions retained (agent is self-contained for its job)
- [ ] Agent within tier limits (Simple <800, Standard <1,200, Complex <1,800)

### Skills Frontmatter Field

**REQUIRED**: All agents MUST include `skills:` field in frontmatter.

**Format**:

```yaml
---
name: agent-name
description: Brief description
tools: Read, Write, Edit
model: inherit
color: blue
skills: [applying-content-quality, creating-accessible-diagrams]
created: YYYY-MM-DD
updated: YYYY-MM-DD
---
```

**EmptySkills**: If agent doesn't use anySkills yet, use empty list:

```yaml
skills: []
```

**MultipleSkills**: List allSkills the agent references:

```yaml
skills: [skill-one, skill-two, skill-three]
```

### Common Duplication Patterns to Avoid

Based on agent simplification audit findings:

| Pattern                                                                   | Instead Use                              | Typical Reduction |
| ------------------------------------------------------------------------- | ---------------------------------------- | ----------------- |
| Content quality standards (active voice, headings, accessibility)         | `docs-applying-content-quality`Skill     | ~50-100 lines     |
| Diagram color palette (Blue #0173B2, Orange #DE8F05...)                   | `docs-creating-accessible-diagrams`Skill | ~60-70 lines      |
| Report generation mechanics (UUID, progressive writing, filename pattern) | Temporary Files Convention               | ~200 lines        |
| Validation methodology (source prioritization, confidence levels)         | `docs-validating-factual-accuracy`Skill  | ~150 lines        |
| Confidence assessment (HIGH/MEDIUM/FALSE_POSITIVE criteria)               | Fixer Confidence Levels Convention       | ~200 lines        |
| Criticality levels (CRITICAL/HIGH/MEDIUM/LOW definitions)                 | `assessing-criticality-confidence`Skill  | ~100 lines        |
| Mathematical notation rules (LaTeX delimiters, display math)              | Mathematical Notation Convention         | ~30 lines         |
| Maker-checker-fixer workflow (three-stage pattern)                        | `applying-maker-checker-fixer`Skill      | ~50 lines         |

### Example: Before and After Simplification

**Before (docs-checker - 1,318 lines)**:

Agent contained full text of:

- Content quality standards (80 lines)
- Diagram color palette with all hex codes (60 lines)
- Report generation mechanics with UUID logic (200 lines)
- Factual validation methodology (150 lines)
- Criticality level definitions (100 lines)
- Mathematical notation validation rules (30 lines)
- Various validation examples (300+ lines)

**After (docs-checker - 515 lines, 60.9% reduction)**:

Agent contains:

- Task-specific validation workflow (what to check)
- BriefSkill references with context
- Links to Conventions for specifications
- Domain-specific examples (concise)
- All task-specific decision logic

**Result**: Agent remains fully functional, easier to maintain, zero knowledge loss (Skills/Conventions provide depth).

### Benefits of Proper Separation

**Maintainability**:

- Update standard once inSkill/Convention, all agents benefit
- No hunting for outdated duplicates across 45 agents
- Single source of truth for each standard

**Clarity**:

- Agents focus on task-specific instructions -Skills provide reusable knowledge on-demand
- Conventions document authoritative specifications

**Efficiency**:

- Smaller agent files (30-60% reduction typical)
- Faster agent loading and processing
- Progressive knowledge delivery (scan agent â†’ dive intoSkill as needed)

**Quality**:

-Skills professionally maintained with examples

- Conventions peer-reviewed and validated
- Agents remain focused on core responsibility

## Agent Documentation Standards

### Required Elements

Every agent must include:

1. PASS: **Clear purpose statement** - What does this agent do?
2. PASS: **Core expertise/responsibility** - What is it an expert in?
3. PASS: **Usage guidelines** - When should you use this agent?
4. PASS: **Reference documentation** - Links to conventions and related docs

### Recommended Elements

Depending on complexity, consider adding:

- **Examples** - Show the agent in action
- **Anti-patterns** - What NOT to do
- **Checklists** - Step-by-step verification
- **Decision trees** - Help users make decisions
- **Troubleshooting** - Common issues and solutions

### Writing Style

Follow these guidelines when writing agent documentation:

1. **Use imperative, direct language**
   - PASS: "Use this agent when creating documentation"
   - FAIL: "This agent could potentially be used for documentation tasks"

2. **Be action-oriented**
   - PASS: "Validates consistency between files"
   - FAIL: "Performs validation activities"

3. **Provide concrete examples**
   - Include code snippets, file examples, command outputs
   - Show both good () and bad () examples

4. **Use checklists where applicable**
   - Break complex tasks into verifiable steps
   - Use `- [ ]` format for actionable items

5. **Be specific, not vague**
   - PASS: "Checks file naming against ex-co\_\_file-naming-convention.md"
   - FAIL: "Validates files"

6. **Follow indentation convention**
   - Agent files are in `.claude/agents/` (primary) or `.opencode/agent/` (secondary) (outside `docs/`), so use standard markdown (spaces for indentation)
   - When agents create/edit files in `docs/`, they must use TAB indentation for nested bullets
   - YAML frontmatter always uses spaces (2 spaces per level) regardless of file location

## Information Accuracy and Verification

### Core Principle

**Verify, never assume.** All agents must prioritize factual accuracy by actively verifying information through tools (Read, Grep, Glob, WebSearch, WebFetch) rather than relying on assumptions or outdated general knowledge.

### Verification Requirements

Use appropriate tools to verify all claims:

- **Code/Implementation**: Read actual source with `Read`, search with `Grep/Glob`, quote line numbers
- **Project Conventions**: Read convention docs before referencing, quote exact sections with file:line
- **External Libraries**: Use `WebSearch/WebFetch` for current docs, cite sources with URLs and dates
- **File Structure**: Use `Glob` to verify paths exist, `Bash` to list contents, report exact paths
- **Commands**: Test all examples, verify outputs match documentation
- **Links**: Use `Glob/Grep` to confirm targets exist before creating links

### Verification Tools Matrix

| Information Type    | Primary Tool | Secondary Tool   | Required?      |
| ------------------- | ------------ | ---------------- | -------------- |
| Code implementation | Read         | Grep, Glob       | PASS: Required |
| Project conventions | Read         | Grep             | PASS: Required |
| File structure      | Glob         | Bash             | PASS: Required |
| External libraries  | WebSearch    | WebFetch         | PASS: Required |
| Official docs       | WebFetch     | WebSearch        | PASS: Required |
| Best practices      | WebSearch    | WebFetch         | Recommended    |
| Historical context  | WebSearch    | Read (changelog) | Recommended    |

### When Verification is Not Possible

If information cannot be verified: (1) State the limitation explicitly, (2) Provide verification steps for the user, (3) Never present unverified information as fact.

### Agent-Specific Requirements

- **Documentation agents (doc-writer)**: Verify code examples, file paths, project structure claims, convention references, external library docs
- **Validation agents (repo-governance-checker)**: Read all files before validating, provide specific line numbers, verify links and frontmatter
- **Development agents**: Read test files, verify command outputs, check error messages, confirm tool availability

### Verification Checklist for Agents

Before providing information, verify:

- [ ] Have I read the actual files being discussed?
- [ ] Have I verified file paths exist?
- [ ] Have I checked the actual code implementation?
- [ ] Have I consulted official documentation for external libraries?
- [ ] Have I provided specific line numbers and file paths?
- [ ] Have I stated clearly what I verified vs. what I assumed?
- [ ] Have I used appropriate tools (Read, Grep, Glob, WebSearch, WebFetch)?
- [ ] Have I cited sources with URLs and access dates?
- [ ] If I cannot verify, have I stated this limitation clearly?
- [ ] Have I provided steps for the user to verify themselves?

## Creating New Agents

### When to Create a New Agent

Create a new agent when:

1. PASS: **New domain or expertise** not covered by existing agents
2. PASS: **Different tool requirements** than existing agents
3. PASS: **Distinct user need** that would benefit from specialization
4. PASS: **Clear, single responsibility** that doesn't overlap

Don't create a new agent when:

1. FAIL: **Existing agent can be extended** with minor modifications
2. FAIL: **Responsibilities overlap** significantly with existing agents
3. FAIL: **Purpose is too vague** or general
4. FAIL: **Temporary or experimental** need (extend existing instead)

### Agent Creation Checklist

Before submitting a new agent, verify:

#### Frontmatter Complete

- [ ] `name` matches filename (kebab-case, no `.md`)
- [ ] `description` clearly states when to use this agent
- [ ] `tools` explicitly lists required tools only (least privilege)
- [ ] `model` set to `inherit` (or justified if specific)
- [ ] `color` assigned based on agent role (blue/green/yellow/purple) - required
- [ ] `skills` field present (can be empty `[]` or list actualSkills) - required

#### Document Structure

- [ ] H1 title follows pattern: `# [Name] Agent`
- [ ] Core responsibility/expertise clearly stated
- [ ] Detailed guidelines provided
- [ ] Reference documentation section included

#### Content Quality

- [ ] Purpose is clear and specific
- [ ] No significant overlap with existing agents
- [ ] Examples provided for usage
- [ ] Anti-patterns documented (what NOT to do)

#### Convention Compliance

- [ ] References `AGENTS.md`
- [ ] References AI agents convention (`ex-de__ai-agents.md`)
- [ ] References relevant domain conventions
- [ ] Links use correct GitHub-compatible format

#### Information Accuracy

- [ ] Agent includes verification requirements for its domain
- [ ] Agent specifies when to use Read/Grep/Glob for verification
- [ ] Agent specifies when to use WebSearch/WebFetch for verification
- [ ] Agent emphasizes verification over assumptions
- [ ] Agent provides examples of good vs bad verification practices

#### File Size Compliance

- [ ] Agent size within appropriate tier limits (Simple: <800 lines, Standard: <1,200 lines, Complex: <1,800 lines)
- [ ] If approaching warning threshold, consider condensation strategies
- [ ] Verified no duplication with convention docs (link instead)

#### Testing

- [ ] Manually tested agent invocation
- [ ] Verified tool permissions are sufficient
- [ ] Confirmed no tool permission creep
- [ ] Verified model selection is appropriate

### Agent Template

Use this template when creating new agents:

```markdown
---
name: agent-name
description: Expert in [domain] specializing in [specific area]. Use when [specific scenario].
tools: Read, Glob, Grep
model: inherit
color: blue
skills: []
created: YYYY-MM-DD
updated: YYYY-MM-DD
---

# Agent Name Agent

You are an expert [role/domain] specializing in [specific expertise].

## Core Responsibility

Your primary job is to [clear, specific purpose statement].

## [Domain-Specific Guidelines]

[Detailed guidelines, standards, examples specific to this agent's domain]

### [Subsection as needed]

[More specific guidance]

## [Additional Sections as Needed]

- Examples
- Checklists
- Decision trees
- Anti-patterns
- Troubleshooting

## Reference Documentation

**Project Guidance:**

- `AGENTS.md` - Primary guidance for all agents working on this project

**Agent Conventions:**

- `governance/development/agents/ai-agents.md` - AI agents convention (all agents must follow)

**[Domain-Specific Conventions]:**

- Relevant conventions for this agent's domain

**Related Agents:**

- Other complementary agents (if applicable)
```

## Relationship to AGENTS.md

### Division of Responsibilities

**AGENTS.md provides:**

- PASS: Project-wide guidance for ALL agents
- PASS: Project overview and context
- PASS: Environment setup (Volta, Node.js, npm)
- PASS: Git hooks and commit conventions
- PASS: High-level documentation organization
- PASS: Reference to this AI agents convention

**Individual agents provide:**

- PASS: Specialized domain expertise
- PASS: Specific task instructions
- PASS: Detailed guidelines for their area
- PASS: Examples and checklists for their domain

**This convention (ex-de\_\_ai-agents.md) provides:**

- PASS: Standards for how agents are structured
- PASS: Agent creation guidelines
- PASS: Tool and model selection criteria
- PASS: Convention referencing requirements

### AGENTS.md Maintenance Standards

**CRITICAL:** AGENTS.md is a navigation document, not a knowledge dump. All agents must help maintain its conciseness.

**Size Limits:**

- **Hard limit:** 40,000 characters (performance threshold - DO NOT EXCEED)
- **Target limit:** 30,000 characters (provides 25% headroom)
- **Warning threshold:** 35,000 characters (time to review and condense)

**Agent Responsibilities:**

1. **repo-governance-maker:**
   - MUST check AGENTS.md size when adding rules
   - Warn user if file exceeds 35,000 characters
   - Suggest condensation strategies (move details to convention docs)
   - Add only 2-5 line summaries to AGENTS.md, link to detailed docs

2. **docs-maker and related content agents:**
   - MUST NOT add verbose content to AGENTS.md
   - When adding conventions, create detailed doc first, then brief AGENTS.md summary
   - Maximum AGENTS.md section length: 3-5 lines + link

3. **All agents:**
   - When in doubt, link to detailed docs rather than duplicate content
   - Each AGENTS.md section should answer "what, where, why" but link to "how"
   - Comprehensive details belong in convention docs, not AGENTS.md

### Agent Isolation and Delivery Pattern

```
Startup: AGENTS.md â”€â”€loadedâ”€â”€> Orchestrator (main conversation)
Runtime: Orchestrator â”€â”€spawnsâ”€â”€> Agents (isolated contexts)
        Skills â”€â”€delivers via skills: fieldâ”€â”€> Agents
         Conventions â”€â”€explicit referencesâ”€â”€> Agents
```

**Critical Understanding:**

1. **Agents have isolated contexts** - They do NOT inherit AGENTS.md
2. **Skills deliver explicitly** - OnlySkills listed in agent's `skills:` field are available
3. **References are explicit** - Agents link to specific conventions they need
4. **Orchestrator has AGENTS.md** - Main conversation loads AGENTS.md, not agents

**Rules:**

1. **Don't duplicate** - Agents should reference conventions, not repeat content
2. **Do specialize** - Agents add domain expertise throughSkills and explicit knowledge
3. **Follow conventions** - All agents must comply with this convention
4. **Declare skills explicitly** - Every agent must have non-empty `skills:` field

### What Belongs Where

| Content Type      | AGENTS.md | Individual Agent | This Convention |
| ----------------- | --------- | ---------------- | --------------- |
| Project overview  | PASS:     | FAIL:            | FAIL:           |
| Environment setup | PASS:     | FAIL:            | FAIL:           |
| Git/commit rules  | PASS:     | FAIL:            | FAIL:           |
| Documentation org | PASS:     | FAIL:            | FAIL:           |
| Agent structure   | FAIL:     | FAIL:            | PASS:           |
| Agent creation    | FAIL:     | FAIL:            | PASS:           |
| Domain expertise  | FAIL:     | PASS:            | FAIL:           |
| Specific tasks    | FAIL:     | PASS:            | FAIL:           |

## Special Cases

### Agent Directory Structure

The `.claude/agents/` directory (primary) and `.opencode/agent/` directory (secondary):

- **Contains** a `README.md` file for agent index and workflow guidance
- **Contains** agent definition files (`.md` files)
- **Follows** flat structure (no subdirectories)

The `.claude/agents/README.md` (primary) and `.opencode/agent/README.md` (secondary) files:

- Lists all available agents with descriptions
- Explains agent workflow and best practices
- Provides guidance on when to use each agent
- Follows the naming exception for README.md files (documented in [File Naming Convention](../../conventions/structure/file-naming.md))

### Agent Versioning

Currently, we don't version agents. If significant changes are needed:

1. **Update in place** for minor improvements
2. **Document changes** in the agent file (update metadata comment)
3. **Consider** creating a new agent if the purpose changes significantly

### Deprecating Agents

If an agent is no longer needed:

1. **Don't delete immediately** - may be referenced
2. **Add deprecation notice** at the top of the agent file
3. **Point to replacement** agent (if applicable)
4. **Remove after** confirming no references exist

## Anti-Patterns

| Anti-Pattern                     | FAIL: Bad                                                           | PASS: Good                                                                                                                                                                      |
| -------------------------------- | ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Vague Description**            | `description: Helper agent for various tasks`                       | `description: Expert documentation writer specializing in Obsidian-optimized markdown and DiÃ¡taxis framework. Use when creating, editing, or organizing project documentation.` |
| **Tool Permission Creep**        | `tools: Read, Write, Edit, Glob, Grep, Bash` (for validation agent) | `tools: Read, Glob, Grep` (read-only for validation)                                                                                                                            |
| **Unnecessary Model Override**   | Using specific model without clear need                             | Use `model: inherit` unless advanced reasoning truly required; then `model: sonnet`                                                                                             |
| **Duplicating AGENTS.md**        | Repeating entire environment setup section                          | Reference: `AGENTS.md` - Primary guidance including environment setup                                                                                                           |
| **Missing Reference Section**    | No references to conventions or AGENTS.md                           | Include Reference Documentation section with links to AGENTS.md and ex-de\_\_ai-agents.md                                                                                       |
| **Overlapping Responsibilities** | `doc-writer-and-validator` (multiple responsibilities)              | Separate `doc-writer` and `doc-validator` agents                                                                                                                                |

## Validation and Compliance

### Repo-Rule-Checker Integration

The `repo-governance-checker` agent validates all agents against this convention.

**Checks performed:**

1. PASS: Frontmatter has all required fields
2. PASS: Agent `name` matches filename
3. PASS: Agent `description` provides clear usage guidance
4. PASS: Agent `tools` field lists tools explicitly
5. PASS: Agent `model` field is present and valid
6. PASS: Document structure follows standard pattern
7. PASS: Reference documentation section exists
8. PASS: References to AGENTS.md and this convention present
9. PASS: Links use GitHub-compatible format

### Manual Verification

Before committing a new agent:

1. **Read this entire convention** - Understand all requirements
2. **Use the agent creation checklist** - Verify all items
3. **Test the agent** - Invoke it and verify behavior
4. **Review existing agents** - Ensure consistency
5. **Run repo-governance-checker** - Validate compliance

## Agent-Skill Separation

**Purpose**: Eliminate duplication between agents by extracting reusable knowledge intoSkills. Agents remain focused on task-specific workflows whileSkills provide shared domain expertise.

### When to UseSkills vs. Agent Content

Use this decision tree to determine where knowledge belongs:

```
Is this knowledge...

â””â”€ Used by 3+ agents?
   â”œâ”€ YES â†’ Extract toSkill
   â””â”€ NO â†’ Keep in agent

â””â”€ Reusable domain expertise? (color palettes, validation standards, report formats)
   â”œâ”€ YES â†’ Create/extendSkill
   â””â”€ NO â†’ Keep in agent

â””â”€ Agent-specific workflow? (task sequence, unique logic, custom decisions)
   â”œâ”€ YES â†’ Keep in agent
   â””â”€ NO â†’ ConsiderSkill

â””â”€ Convention details? (standards, rules, formats)
   â”œâ”€ YES â†’ Link to convention document, optionally referenceSkill
   â””â”€ NO â†’ Evaluate based on above criteria
```

### What Belongs inSkills

**Extract toSkills** (reusable knowledge):

1. **Validation Standards**
   - UUID chain generation logic
   - Progressive writing methodology
   - Report file naming patterns
   - Timestamp generation (UTC+7)
   - Criticality level definitions
   - Confidence assessment criteria

2. **Domain Expertise**
   - Hugo theme patterns (Hextra, PaperMod)
   - Content quality principles
   - Color accessibility palettes
   - Annotation density standards
   - DiÃ¡taxis framework application
   - Gherkin syntax rules

3. **Shared Workflows**
   - Maker-Checker-Fixer pattern
   - Link validation methodology
   - Factual accuracy verification
   - Mode parameter handling
   - Report discovery logic

### What Belongs in Agents

**Keep in Agents** (task-specific content):

1. **Task Workflows**
   - Step-by-step execution sequence
   - Agent-specific validation logic
   - Custom decision trees
   - Unique processing rules

2. **Scope Definitions**
   - What files/directories to validate
   - What to include/exclude
   - Agent mission and responsibilities
   - Collaboration with other agents

3. **Tool Usage Patterns**
   - How to use Read/Write/Bash/etc.
   - Tool combinations for specific tasks
   - Error handling strategies

4. **Output Formats**
   - Agent-specific report structures
   - Custom finding categories
   - Unique recommendation formats

### Examples of Good Separation

#### Example 1: Checker Agent

**Before Simplification** (800+ lines):

```markdown
# docs-checker Agent

## UUID Generation

[200 lines of UUID chain logic, timestamp generation]

## Criticality Levels

[150 lines defining CRITICAL/HIGH/MEDIUM/LOW]

## Report Template

[100 lines of report structure examples]

## Validation Workflow

[350 lines of task-specific validation logic]
```

**After Simplification** (350 lines):

```markdown
---
skills:
  - generating-validation-reports
  - assessing-criticality-confidence
  - applying-content-quality
---

# docs-checker Agent

## Report Generation

See `generating-validation-reports`Skill for UUID chains, timestamps, progressive writing.

## Criticality Assessment

See `assessing-criticality-confidence`Skill for level definitions.

## Validation Workflow

[350 lines of task-specific validation logic - RETAINED]
```

**Result**: 450 lines removed (56%), all functionality preserved.

#### Example 2: Ayokoding Content Agent

**Before Simplification** (1,100+ lines):

```markdown
# apps-ayokoding-web-by-example-maker

## Hugo Weight System

[150 lines explaining level-based weights]

## Annotation Standards

[200 lines defining 1-2.25 comment ratio]

## Bilingual Strategy

[100 lines of Indonesian/English patterns]

## Five-Part Example Structure

[150 lines of example format]

## Creation Workflow

[500 lines of task-specific content creation]
```

**After Simplification** (500 lines):

```markdown
---
skills:
  - apps-ayokoding-web-developing-content
  - docs-creating-by-example-tutorials
---

# apps-ayokoding-web-by-example-maker

## Hugo Patterns

See `apps-ayokoding-web-developing-content`Skill for weight system, bilingual strategy.

## Example Structure

See `docs-creating-by-example-tutorials`Skill for five-part format, annotation density.

## Creation Workflow

[500 lines of task-specific content creation - RETAINED]
```

**Result**: 600 lines removed (55%), all patterns available viaSkills.

### Decision Tree Examples

**Scenario 1**: Adding color palette to diagram-creating agent

```
Knowledge: Accessible color palette (Blue #0173B2, Orange #DE8F05, etc.)

Q: Used by 3+ agents?
A: YES (8+ agents create diagrams)

Q: Reusable domain expertise?
A: YES (color accessibility is universal)

Decision: Extract to `docs-creating-accessible-diagrams`Skill
```

**Scenario 2**: Adding custom validation logic for plan structure

```
Knowledge: Plan must have README.md, requirements.md, delivery.md

Q: Used by 3+ agents?
A: NO (only plan-checker validates plan structure)

Q: Agent-specific workflow?
A: YES (unique to plan validation)

Decision: Keep in plan-checker agent
```

**Scenario 3**: Adding mode parameter handling to fixer agents

```
Knowledge: lax/normal/strict/ocd modes filter findings by criticality

Q: Used by 3+ agents?
A: YES (all 15 fixer agents use mode parameter)

Q: Reusable domain expertise?
A: YES (mode handling is standardized)

Decision: Extract to `applying-maker-checker-fixer`Skill
```

### Benefits of Agent-Skill Separation

1. **Single Source of Truth**: UpdateSkill once, all agents benefit
2. **Reduced Duplication**: Eliminate 50-90% of duplicated content
3. **Easier Maintenance**: Convention changes require updatingSkill only
4. **Better Scalability**: New agents reference existingSkills
5. **Clearer Agents**: Agents focus on task workflows, not standards
6. **Progressive Disclosure**:Skills load on-demand, reducing context bloat

### Implementation Pattern

When simplifying an agent:

1. **Identify duplication**: Look for content appearing in 3+ agents
2. **Check existingSkills**: Does aSkill already cover this?
   - YES â†’ Reference theSkill
   - NO â†’ Consider creating newSkill
3. **Extract toSkill**: Create/extendSkill with reusable knowledge
4. **Update agent**: Replace duplicated content withSkill reference
5. **Add frontmatter**: IncludeSkill in `skills:` field
6. **Verify size**: Confirm agent is within tier limits
7. **Test functionality**: Ensure agent still works correctly

### Measurement and Success Criteria

**Target Size Reduction**: 20-40% average across all agents

**Quality Metrics**:

- All agents within tier limits (Simple <800, Standard <1,200, Complex <1,800)
- Zero functionality regressions
- AllSkills referenced exist
- All convention links valid

**Project Achievement** (2026-01-03):

- 45 agents simplified
- 82.7% average reduction (4x better than target)
- 28,439 lines eliminated
- 100% tier compliance (all in Simple tier)
- 18Skills created/used

### Ongoing Vigilance

**Prevent duplication creep**:

1. **New agent creation**: ReferenceSkills instead of duplicating
2. **Agent updates**: Extract new duplication toSkills
3. **Periodic audits**: Run repo-governance-checker for duplication detection
4. **Code reviews**: Check for embeddedSkill knowledge
5. **Documentation**: Keep AI Agents Convention updated with examples

### RelatedSkills

**CurrentSkills** (18 total):

- `generating-validation-reports` - Report generation, UUID chains, timestamps
- `assessing-criticality-confidence` - Criticality levels, confidence assessment
- `applying-maker-checker-fixer` - Three-stage workflow, mode handling
- `apps-ayokoding-web-developing-content` - Hugo Hextra patterns, bilingual content
- `apps-oseplatform-web-developing-content` - Hugo PaperMod patterns
- `docs-creating-by-example-tutorials` - Annotation standards, five-part structure
- `docs-creating-accessible-diagrams` - Color palettes, accessibility
- `docs-applying-content-quality` - Markdown quality standards
- `docs-validating-factual-accuracy` - Verification methodology
- `validating-links` - Link validation, caching
- Plus 8 more in Content Creation, Standards Application, Process Execution categories

See [Skills README](../../../.claude/skills/README.md) for complete catalog.

## Related Documentation

- [Development Index](../README.md) - Overview of development conventions
- [Conventions Index](../../conventions/README.md) - Documentation conventions
- [Color Accessibility Convention](../../conventions/formatting/color-accessibility.md) - Master reference for all color usage (agent categorization, diagrams, accessibility standards)
- [File Naming Convention](../../conventions/structure/file-naming.md) - How to name files
- [Linking Convention](../../conventions/formatting/linking.md) - How to link between files
- [DiÃ¡taxis Framework](../../conventions/structure/diataxis-framework.md) - Documentation organization
- [Implementation Workflow Convention](../workflow/implementation.md) - Surgical changes (touch only what you must) and goal-driven execution (define success criteria, loop until verified) practices for agents

---

**Last Updated**: 2026-01-29

---

## Dual Mode Operation

**Added**: 2026-01-16

This repository maintains **dual compatibility** with both Claude Code (`.claude/`) and OpenCode (`.opencode/`) systems.

### Directory Structure

```
.
â”œâ”€â”€ .claude/                 # Claude Code configuration (PRIMARY - Source of Truth)
â”‚   â”œâ”€â”€ agents/             # 57 agents in Claude Code format
â”‚   â”œâ”€â”€ skills/             # 34 skills
â”‚   â””â”€â”€ settings.local.json # MCP servers configuration
â””â”€â”€ .opencode/              # OpenCode configuration (SECONDARY - Auto-generated)
    â”œâ”€â”€ agent/              # 57 agents in OpenCode format (synced from .claude/)
    â”œâ”€â”€ skill/              # 34 skills (direct copy from .claude/)
    â””â”€â”€ opencode.json       # OpenCode configuration
```

### Source of Truth Hierarchy

**`.claude/` is the canonical source**. All updates happen here first, then sync to `.opencode/`.

**Making Changes**:

1. Edit agents in `.claude/agents/` directory (PRIMARY)
2. Edit skills in `.claude/skills/` directory (PRIMARY)
3. Run sync: `npm run sync:claude-to-opencode`
4. Changes automatically regenerate `.opencode/` (SECONDARY)

**Rationale**: Single source of truth prevents conflicts, ensures consistency, simplifies maintenance.

### Format Differences

Both systems use markdown agents with YAML frontmatter, but with different conventions:

#### Tools Format

**Claude Code** (`.claude/agents/`):

```yaml
tools: [Read, Write, Edit, Glob, Grep, Bash]
```

Array format with capitalized tool names.

**Primary: Claude Code** (`.claude/agents/`), **Secondary: OpenCode** (`.opencode/agent/`):

```yaml
tools:
  read: true
  write: true
  edit: true
  glob: true
  grep: true
  bash: true
```

Boolean flags format (nested YAML).

#### Model References

**Claude Code**:

```yaml
model: sonnet # or opus, haiku, or omit for inherit
```

**OpenCode**:

```yaml
model: zai/glm-4.7     # sonnet equivalent
model: zai/glm-4.5-air # haiku equivalent
model: inherit         # inherits from parent
```

#### Skills Format

**Identical for both systems** -Skills use the same SKILL.md format:

```yaml
---
description: Brief description
---
#Skill Name
Content...
```

Skills are **directly copied** from `.claude/skills/` to `.opencode/skill/` (no conversion needed).

### Sync Automation

**Script**: `scripts/sync-agent-configs.sh` (or `.js`)

**Commands**:

- `npm run sync:claude-to-opencode` - Full sync (agents + skills)
- `npm run sync:agents` - Agents only
- `npm run sync:skills` -Skills only (direct copy)
- `npm run validate:sync` - Verify semantic equivalence

**Conversion Logic**:

- **Agents**: Claude Code format â†’ OpenCode format (tool arrays â†’ boolean flags, model mapping)
- **Skills**: Direct copy (no conversion, format identical)
- **Validation**: Confirms both directories are semantically equivalent

### Documentation References

- **[CLAUDE.md](../../../CLAUDE.md)** (PRIMARY) - Claude Code configuration
- **[AGENTS.md](../../../AGENTS.md)** (SECONDARY) - OpenCode configuration with auto-generated warning
- **[.claude/agents/README.md](../../../.claude/agents/README.md)** (PRIMARY) - Agent catalog
- **[.opencode/agent/README.md](../../../.opencode/agent/README.md)** (SECONDARY) - OpenCode agent catalog with warning
- **[.claude/skills/README.md](../../../.claude/skills/README.md)** (PRIMARY) -Skills catalog
- **[.opencode/skill/README.md](../../../.opencode/skill/README.md)** (SECONDARY) - OpenCode skills catalog with warning

### Migration History

- **2026-01-12**: Initial OpenCode migration (45 agents)
- **2026-01-16**: Dual-mode setup established, `.claude/` created as source of truth (46 agents)

### Best Practices

1. **Always edit `.claude/` first** - Never edit `.opencode/` directly (changes will be overwritten)
2. **Run sync after changes** - Ensure `.opencode/` stays synchronized
3. **Test both systems** - Verify agents work in both Claude Code and OpenCode after major changes
4. **Document sync status** - Keep README files updated in both directories
5. **Security policy** - Only use skills from trusted sources (both systems)

### Troubleshooting

**Problem**: `.opencode/` agents out of sync with `.claude/`
**Solution**: Run `npm run sync:claude-to-opencode` to regenerate

**Problem**: Conversion errors during sync
**Solution**: Check agent frontmatter format in `.claude/agents/`, fix YAML syntax, re-sync

**Problem**:Skills missing in one directory
**Solution**: Verify skills exist in `.claude/skills/`, run `npm run sync:skills`

---

**Last Updated**: 2026-01-16
**See Also**: [Repository Governance Architecture](../../repository-governance-architecture.md)
